# 設計書：学習なしで「AIのべりすと」級の創作体験を提供するローカル指向プロダクト

（ベース：Qwen3-1.7B／拡張：多プロバイダ対応／ICL＋コンテクストエンジニアリング＋Swarm）

---

## 0. 定義

* **学習なし**：DAPT/SFT/LoRAなどの重み更新を行わず、推論時の構造（ICL、ルール、記憶、検査・修正ループ）で品質を作る。
* **ICL**：少数例（悪い例→良い例など）をコンテクストに入れて挙動を寄せる。
* **Prompt Program**：単発プロンプトではなく、毎回決まった「入力構造」を組み立てるプログラム（Bible／State／Scene／Memory…）。
* **Swarm**：複数の“役割プロンプト”を持つエージェント群で、生成→検査→修正を少回数で回す。
* **プロバイダ**：ローカル実行（例：Ollama、LM Studio）＋クラウドAPI（例：OpenAI、Anthropic、Google 等）を抽象化して差し替え可能にする。

---

## 1. 目的と非目的

### 目的

1. **ワンクリックで使える**：ローカルで起動→ブラウザUIで即執筆開始
2. **破綻しにくい長編運用**：章を跨いでキャラ・事実・伏線が崩れにくい
3. **低コスト**：基本ローカル推論、必要ならクラウドへ“差し替え”
4. **拡張性**：モデル／プロバイダ／エージェント／記憶ストアをプラグインで増やせる

### 非目的（最初はやらない）

* 完全自律の長編自動連載（まずは人間主導の補助が主）
* 無限に長いコンテクスト（要約・事実抽出で圧縮する）
* 高度な画像・音声統合（後回し）

---

## 2. ユーザ体験（UX）要件：プロダクトとしての完成度

### 主要ユーザストーリー

* **S1**：世界観テンプレを選んで、キャラを2人作って、第一話を書き始めたい
* **S2**：途中で矛盾が出たので、矛盾箇所だけ直して続きを書かせたい
* **S3**：同じシーンを「硬派」「コメディ」「詩的」で書き分けたい
* **S4**：ローカルが遅いので、クラウドに切り替えて同じ作品を続行したい
* **S5**：作品データ（Bible/Memory/Chapters）を丸ごとエクスポートしたい

### UI（最小で強い）

* 左：**作品ツリー**（Bible / Characters / Chapters / Memory / Prompts）
* 中央：**エディタ**（章・シーン本文）
* 右：**コントロール**（モード、出力長、文体、検査、差分修正、プロバイダ切替）
* 下：**実行ログ**（どのエージェントが何をしたか、token/cost、失敗理由）

---

## 3. システム全体像（MVPアーキテクチャ）

### データ構造（SSOT：Single Source of Truth）

* `Project/`

  * `bible.md`（世界観規約）
  * `characters/*.json`（キャラカード）
  * `chapters/*.md`（本文）
  * `memory/episodic.md`（直近要約）
  * `memory/facts.json`（不変・確定事実）
  * `memory/foreshadow.json`（伏線リスト）
  * `runs/*.jsonl`（各実行の入出力ログ）

### 実行パイプライン（2段生成＋検査）

1. **Director**：SceneSpec（狙い・制約・伏線・視点）を生成
2. **Writer**：SceneSpecを入力に本文生成（原則“思考文”を出さない）
3. **ContinuityChecker**：矛盾・口調・視点・設定逸脱を検出
4. **StyleEditor**：文章整形（テンポ、改行、言い回し、重複）
5. **Committer**：Memory更新（要約/事実/伏線の差分）＋成果物保存
   ※修正ループは **最大1回**（無限ループを防止）

---

## 4. 多プロバイダ対応の設計（拡張性の核）

### 4.1 Provider Abstraction Layer（PAL）

“チャット生成”を1つのインターフェースに統一する。

**共通I/F（例）**

* `generate(messages, params) -> text | stream`
* `capabilities() -> {ctx_len, tools, json_mode, thinking_mode, ...}`
* `price_estimate(tokens) -> cost`（任意）
* `healthcheck()`

**プロバイダ差分吸収ポイント**

* システムメッセージの扱い（system禁止のAPI等）
* JSONモード／ツール呼び出し／関数呼び出し
* コンテクスト長上限
* thinking切替の表現（フラグ、特殊トークン、温度設計など）

### 4.2 “能力宣言”でルーティング

モデルによって得意不得意があるので、**エージェントごとに要求能力を宣言**し、PALが最適モデルへ割り当てる。

例：

* Director：長文・構造化が得意、JSON出力が安定
* Writer：創作が得意、冗長抑制
* Checker：厳格・短文でOK

→ ローカルが弱いなら Checkerだけクラウド、などが可能。

---

## 5. コンテクストエンジニアリング（学習なし品質の心臓）

### 5.1 Prompt Programの固定フォーマット

毎回「同じ枠」を埋める。これだけでブレが激減する。

**Promptブロック**

1. `Style Bible`（文体規約：一人称、文末、比喩、禁止語、改行ルール）
2. `World Bible`（世界観、技術水準、用語集、禁則）
3. `Character Cards`（口調・価値観・関係性・禁句）
4. `Facts`（確定事実：短い箇条書き/JSON）
5. `Episodic Recap`（直近要約：200〜400字）
6. `SceneSpec`（今回の設計図：10〜20行）
7. `ICL Examples`（マイクロ例×3：悪い→良い、口調、地の文テンポ）

### 5.2 コンテクストの“圧縮戦略”

長編は必ず溢れるので、圧縮を仕様化する。

* Factsは **増やしすぎない**（可変情報はEpisodicへ）
* Episodicは **直近Nシーンのみ**（古いのは要約を上書き）
* 伏線は **ID管理**（回収/未回収、関連章）

---

## 6. Agent Swarm設計（最小で破壊力）

### 6.1 MVPのエージェント構成（5体）

* **Director**：SceneSpec生成（構造化テキスト/JSON）
* **Writer**：本文生成（指定文体・指定視点）
* **ContinuityChecker**：矛盾・逸脱検出（指摘だけ。本文は書かない）
* **StyleEditor**：冗長・反復・テンポ改善（差分修正）
* **Committer**：Memory更新・成果物保存・ログ記録

### 6.2 ループ上限（プロダクトとして重要）

* 検査→修正は **最大1回**
* それでもダメなら「失敗理由（制約衝突）」を返してユーザに選ばせる
  （自動で延々やると遅い・高い・不透明の三重苦）

---

## 7. 評価と品質保証（“使える”の最低ライン）

### 自動メトリクス（軽量）

* メタ発言率（NGフレーズ辞書）
* 反復率（n-gram重複）
* 事実矛盾数（Factsとの照合ルール）
* キャラ逸脱数（口調・一人称・禁句）

### 手動（最重要）

* 固定の20プロンプト回帰テスト（ジャンル別）
* バージョン差分（プロンプト変更で品質が落ちてないか）

---

## 8. セキュリティ・プライバシー（ローカルの強みを殺さない）

* 作品データはローカル保存がデフォ
* クラウド利用時は「送信される範囲」をUIで明示（Bible/Memory/本文のどこまで）
* APIキーはOSの秘密領域（Keychain/credential store）に保存

---

## 9. デプロイ形態（簡単に使える完成度）

### MVP推奨：ローカルWebアプリ

* ローカルで1コマンド起動（バックエンド）
* ブラウザUI（フロント）
* 作品はローカルフォルダ＝そのままGit管理も可能

将来：

* デスクトップ（Electron等）
* 共有サーバ（チーム利用）

---

## 10. 設定ファイル（拡張性のための“中心点”）

`config.yaml`（例：概念）

* `provider.default = local_ollama`
* `provider.routing = {director: cloud_x, writer: local, checker: cloud_y}`
* `context.budgets = {bible: 1500, characters: 1200, facts: 600, recap: 400, icl: 600}`
* `swarm.max_revision = 1`
* `logging = {save_prompts: true, save_outputs: true}`

---

## 11. 実装優先順位（ロードマップ）

### Phase 0（2〜3日）：使える骨格

* プロジェクト形式（SSOTファイル群）
* Writer単体＋Bible読み込み
* ローカルプロバイダ1つ（Qwen3-1.7B）

### Phase 1（+3〜5日）：2段生成と記憶

* Director→Writer
* Memory（Episodic/Facts/伏線）更新
* 回帰テスト20本

### Phase 2（+1〜2週）：Swarmと多プロバイダ

* Checker/Editor/Committer追加
* PAL実装＋プロバイダ2種以上対応
* ルーティング（役割別モデル割当）
* トークン・コスト・速度可視化

---

## 12. “Qwen3-1.7B前提”での現実的な運用Tips

* 生成の品質は「ICLの質」と「SceneSpecの粒度」で決まる
* 長編は「Facts肥大化」で死ぬ → Factsは短く、Episodicで流す
* Swarmは増やしすぎると遅くなる → まず5体、修正1回上限

---

# 次にやること（設計から実装へ落とす最短）

この設計書を“動く仕様”にするには、まず以下3点を確定するとブレません。

1. **SSOTのファイル形式**（bible/characters/facts/recap/chapters のスキーマ）
2. **SceneSpecフォーマット**（Directorの出力形式：JSONかテキストか）
3. **PALの最小インターフェース**（generate/stream/capabilities）

ここまで固めると、モデルやプロバイダを増やしてもプロダクトが崩れない「背骨」ができます。
